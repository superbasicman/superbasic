/**
 * Integration tests for authentication middleware
 * Tests JWT extraction, validation, and user context attachment
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { Hono } from 'hono';
import { authMiddleware } from '../auth.js';
import { resetDatabase } from '../../test/setup.js';
import { makeRequest, createTestUser } from '../../test/helpers.js';
import {
  COOKIE_NAME,
  SESSION_MAX_AGE_SECONDS,
  JWT_SALT,
  authConfig,
  CLOCK_SKEW_TOLERANCE_SECONDS,
} from '@repo/auth';
import { encode } from '@auth/core/jwt';

// Define context variables type
type AuthContext = {
  Variables: {
    userId: string;
    userEmail: string;
    jti: string;
  };
};

// Create a test app with auth middleware
function createTestApp() {
  const app = new Hono<AuthContext>();

  // Protected route that uses auth middleware
  app.get('/protected', authMiddleware, async (c) => {
    return c.json({
      userId: c.get('userId'),
      userEmail: c.get('userEmail'),
      jti: c.get('jti'),
    });
  });

  return app;
}

describe('Authentication Middleware', () => {
  beforeEach(async () => {
    await resetDatabase();
  });

  describe('JWT Extraction and Validation', () => {
    it('should extract and validate JWT from cookie', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create valid token
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.userId).toBe(user.id);
      expect(data.userEmail).toBe(user.email);
      expect(data.jti).toBeTruthy(); // JTI is auto-generated by encode
      expect(typeof data.jti).toBe('string');
    });

    it('should return 401 when cookie is missing', async () => {
      const app = createTestApp();

      const response = await makeRequest(app, 'GET', '/protected');

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data).toHaveProperty('error');
      expect(data.error).toBe('Unauthorized');
    });

    it('should return 401 for invalid JWT format', async () => {
      const app = createTestApp();

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: 'invalid-token',
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data).toHaveProperty('error');
    });

    it('should return 401 for JWT with invalid signature', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token with wrong secret
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: 'wrong-secret',
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);
    });

    it('should return 401 for expired JWT', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create expired token using negative maxAge (beyond clock skew tolerance)
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: -CLOCK_SKEW_TOLERANCE_SECONDS - 3600, // Expired beyond tolerance
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).toBe('Unauthorized');
    });

    it('should accept JWT within clock skew tolerance', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token that expired just within clock skew tolerance
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
          exp: Math.floor(Date.now() / 1000) - (CLOCK_SKEW_TOLERANCE_SECONDS - 10),
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);
    });

    it('should return 401 for JWT without user ID', async () => {
      const app = createTestApp();

      // Create token without id field
      const token = await encode({
        token: {
          email: 'test@example.com',
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);
    });
  });

  describe('User Context Attachment', () => {
    it('should attach userId to request context', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.userId).toBe(user.id);
      expect(typeof data.userId).toBe('string');
    });

    it('should attach userEmail to request context', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.userEmail).toBe(user.email);
      expect(typeof data.userEmail).toBe('string');
    });

    it('should attach jti to request context', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.jti).toBeTruthy(); // JTI is auto-generated by encode
      expect(typeof data.jti).toBe('string');
      expect(data.jti.length).toBeGreaterThan(0);
    });

    it('should attach all context variables for valid token', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
          jti: 'test-jti',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data).toHaveProperty('userId');
      expect(data).toHaveProperty('userEmail');
      expect(data).toHaveProperty('jti');
      expect(Object.keys(data)).toEqual(['userId', 'userEmail', 'jti']);
    });
  });

  describe('Invalid Claims Rejection', () => {
    it('should return 401 for token with invalid issuer', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token with wrong issuer
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'wrong-issuer',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).toBe('Invalid token claims');
    });

    it('should return 401 for token with invalid audience', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token with wrong audience
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'wrong-audience',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).toBe('Invalid token claims');
    });

    it('should return 401 for token with missing issuer', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token without issuer
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).toBe('Invalid token claims');
    });

    it('should return 401 for token with missing audience', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token without audience
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).toBe('Invalid token claims');
    });

    it('should return 401 for token with both invalid issuer and audience', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token with both wrong issuer and audience
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'wrong-issuer',
          aud: 'wrong-audience',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).toBe('Invalid token claims');
    });

    it('should accept token with correct issuer and audience', async () => {
      const { user } = await createTestUser();
      const app = createTestApp();

      // Create token with correct claims
      const token = await encode({
        token: {
          sub: user.id,
          id: user.id,
          email: user.email,
          iss: 'sbfin',
          aud: 'sbfin:web',
        },
        secret: authConfig.secret!,
        salt: JWT_SALT,
        maxAge: SESSION_MAX_AGE_SECONDS,
      });

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: token,
        },
      });

      expect(response.status).toBe(200);
    });
  });

  describe('Middleware Error Handling', () => {
    it('should return 401 for any authentication error', async () => {
      const app = createTestApp();

      // Test with completely invalid token
      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: 'completely-invalid',
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data).toHaveProperty('error');
    });

    it('should not leak error details in response', async () => {
      const app = createTestApp();

      const response = await makeRequest(app, 'GET', '/protected', {
        cookies: {
          [COOKIE_NAME]: 'invalid',
        },
      });

      expect(response.status).toBe(401);

      const data = await response.json();
      expect(data.error).not.toContain('stack');
      expect(data.error).not.toContain('decode');
      expect(data.error).not.toContain('secret');
    });

    it('should handle missing cookie gracefully', async () => {
      const app = createTestApp();

      const response = await makeRequest(app, 'GET', '/protected');

      expect(response.status).toBe(401);
      expect(response.headers.get('content-type')).toContain('application/json');
    });
  });
});
