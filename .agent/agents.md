# SuperBasic Agents Guide

## Product Overview

SuperBasic Finance is an API-first personal finance platform built in a monorepo. The web client is a thin React SPA that consumes a typed `/v1` JSON API. Developers can provision API keys to build their own tools, with future MCP server support on the roadmap.

## Core Principles

- **API-first**: Stable `/v1` JSON endpoints backed by Zod schemas with autogenerated OpenAPI 3.1 contracts.
- **Secure by design**: Auth.js sessions, hashed PATs, least-privilege Prisma access, Upstash-backed rate limits, and auditable changes.
- **Thin client**: React SPA talks only to the public API via a generated SDK; no direct DB access or secrets in `apps/web`.
- **Portable**: Pure client-side SPA architecture that can be wrapped with Capacitor for mobile deployment when needed.
- **Extensible**: Workspace-aware multi-tenancy, saved views, budgets, exports, and fine-grained API scopes for both UI and API keys.
- **Operationally simple**: Vercel deploys, serverless-friendly jobs (QStash workers), and reproducible migrations.

## Mission Snapshot

- Focus areas for v1: Plaid-powered bank sync, Stripe billing, workspace-scoped multi-tenancy, append-only ledger, and API key–driven integrations.
- Non-goals (v1): native mobile clients, spreadsheet-style UI, full double-entry accounting.

## How to Use This Guide (and Phases)

- This file is the **orientation + guardrails** for agents.
- The **current active work** is defined in:
  - `.scope/current-phase.md`
  - `.scope/project_plan.md`
- When picking up a task:
  1. Read the relevant phase doc.
  2. Skim the corresponding spec under `docs/` (for example, `database-structure-*.md`, `api/*.md`).
  3. Follow the conventions and guardrails in this guide.

Only touch the tables, routes, and packages that belong to the active phase. If you think a spec is wrong or missing, update the spec first, then code.

## Key Features

- Auth.js authentication + personal access token (PAT) management.
- Stripe integration for billing (Checkout, Portal, webhooks).
- Plaid Link for bank connections with server-side token exchange.
- Workspace-scoped multi-tenancy.
- Append-only financial ledger for transactions and adjustments.
- Background job processing via Upstash QStash (long syncs) and Vercel Cron (short triggers).

## Monorepo Map

pnpm workspace + Turborepo layout:

    .
    ├─ apps/
    │  ├─ api/                  # Hono API server exposing /v1 routes (Node adapter)
    │  │  └─ src/routes/v1/     # API route handlers
    │  │     ├─ billing.checkout.ts
    │  │     ├─ billing.portal.ts
    │  │     └─ webhooks.stripe.ts
    │  └─ web/                  # Thin React SPA (Vite, calls API only)
    ├─ packages/
    │  ├─ core/                 # Domain logic (billing, ledgers, limits)
    │  ├─ db/                   # Prisma schema + migrations + client exports
    │  ├─ types/                # Zod contracts shared across layers
    │  ├─ auth/                 # Auth.js adapters, PAT hashing, RBAC scopes
    │  ├─ sdk/                  # Generated OpenAPI client
    │  ├─ observability/        # Logging, tracing, audit emitters
    │  ├─ rate-limit/           # Upstash helpers
    │  ├─ design-system/        # Tailwind CSS React components (no third-party UI libs)
    │  └─ payments/             # Stripe SDK wrappers + webhook helpers
    └─ tooling/
       ├─ ci/                   # GitHub Actions / Turborepo presets
       └─ scripts/              # Migration + release automation

## Conventions

### Database & RLS Overview

We maintain a detailed `database-structure.md` (split into smaller section files) as the **single source of truth** for our schema. Before making any schema or query changes, skim that doc and work within its decisions.

Key principles agents must respect:

- **Auth vs domain**: Auth.js tables (`users`, `accounts`, `sessions`, `verification_tokens`) are handled via the Auth.js adapter. Our domain model starts at `profiles.id` and flows:
  `profiles → workspaces → connections → bank_accounts → transactions → overlays`.
- **Append-only ledger**: `transactions` are immutable. User edits (renames, recategorization, splits, notes, hide flags) live in overlay tables, not by mutating the base transaction row.
- **Multi-tenant by RLS**: Every query must be compatible with row-level security based on `current_setting('app.user_id'/'app.profile_id'/'app.workspace_id')`. Never add queries that “bypass RLS” or rely on cross-tenant access.
- **Workspaces borrow connections**: Connections are owned by a profile. Workspaces see accounts/transactions only via explicit links/scopes (workspace membership + connection/account scopes).
- **Budgets & categories**: Budgets are modeled on top of categories and overlays; don’t invent ad-hoc budget tables or category fields. Extend the existing category/budget/overlay layering instead.

Implementation is **phase-based** (for example, Auth & Profiles, Plaid & Bank, Workspaces & Budgets). When working on a task, only touch the tables and features in that phase. If you believe the schema needs to change, propose an update to the relevant `database-structure-*.md` section first, then implement.

### API Structure (`apps/api`)

- All public routes live under:  
  `apps/api/src/routes/v1/`
- Route files are named by **resource** and **action**:  
  `{resource}.{action}.ts` (for example, `billing.checkout.ts`, `billing.portal.ts`).
- Each route file:
  - Exports Zod schemas for request/response validation.
  - Exports the handler wired into Hono.
  - Feeds OpenAPI generation (keep schemas co-located).
- OpenAPI 3.1 spec is served at:
  - `GET /v1/docs` → Swagger UI.
- All `/v1` responses are **JSON only**.
- **Bearer auth is required on all `/v1` routes**:
  - Accepts PATs or JWTs.
- Controllers stay thin:
  - Parse/validate.
  - Call services.
  - Map domain errors → HTTP status + JSON body.
  - They **never** touch Prisma directly.

### Web Client (`apps/web`)

- Vite + React 19 SPA (pure client-side).
- React Router for routing.
- **Client stays pure**:
  - No direct database access.
  - No Prisma.
  - No server-side secrets.
- All data flows through the public API:
  - All API calls via **TanStack Query** + the generated **SDK**.
- **No Stripe/Plaid secrets in the browser**:
  - All sensitive operations (Stripe billing, Plaid token exchange) go through the API.
- Architecture is **Capacitor-ready**:
  - SPA can be wrapped for iOS/Android without special casing.

### Shared Packages

Use workspace aliases (`@repo/*`) instead of relative paths:

- **`@repo/database`** → `packages/db`  
  Prisma schema, migrations, and client exports.
- **`@repo/types`**  
  Zod schemas shared between API and web; source of OpenAPI contracts.
- **`@repo/auth`**  
  Auth.js configuration, PAT utilities, RBAC scope definitions.
- **`@repo/sdk`**  
  Generated OpenAPI client used by `apps/web` and external tools.
- **`@repo/payments`**  
  Stripe SDK wrappers and webhook helpers/handlers.
- **`@repo/rate-limit`**  
  Upstash Redis rate-limiting utilities (middleware, helpers).
- **`@repo/observability`**  
  Logging, tracing, and audit trail emitters.
- **`@repo/design-system`**  
  Custom React components built with Tailwind CSS.  
  - No third-party UI libraries (keep things predictable and tree-shakable).

Shared packages should:

- Export **named APIs** (avoid default exports).
- Keep surface areas small and well-typed.
- Be dependency-light to stay usable across app and worker contexts.

### File Naming

- Use **kebab-case** for files:
  - `billing-service.ts`
  - `user-repository.ts`
- Route files:
  - `{resource}.{action}.ts` (for example, `billing.checkout.ts`).
- Test files:
  - `{filename}.test.ts` or `{filename}.spec.ts`.
- Type/schema files:
  - `{domain}.types.ts` or `{domain}.schema.ts`.
- Keep folders domain-oriented (for example, `billing/`, `ledger/`, `workspace/`).

### Import Conventions

- Prefer workspace aliases over deep relative paths:
  - `@repo/database`, `@repo/types`, `@repo/auth`, etc.
- Prefer **named exports** over default exports.
- Import order:
  1. External libraries (`react`, `hono`, `zod`, etc.).
  2. Workspace aliases (`@repo/*`).
  3. Relative imports (`./foo`, `../bar`).
- Keep side-effect imports (`import './tracing'`) isolated and documented.

### Background Jobs

- Initial Plaid sync:
  - Enqueued to **Upstash QStash** worker (can be long-running).
- Manual “Sync Now”:
  - Client-driven batching, each request should complete in **< 10s**.
- Periodic tasks:
  - **Vercel Cron** for quick tasks only.
  - Cron can also enqueue work to **QStash** for heavier processing.
- All jobs:
  - Use cursors and `processed_events` for **idempotency**.
  - Log enough context for replay & debugging via `@repo/observability`.

### Testing Organization

- **Unit tests**:
  - Vitest in packages (`core`, `auth`, `db`, etc.).
- **Integration tests**:
  - Supertest/undici against `/v1` handlers.
  - Use seeded test DB schemas via Prisma.
- **E2E tests**:
  - Playwright in `apps/web` for primary user flows.
- **Contract tests**:
  - OpenAPI spec diffing in CI:
    - Ensure SDK + docs stay consistent with handlers.
- When running from agents/non-interactive environments:
  - Use `--run` to avoid watch mode (see section at bottom).

### Things Agents Should Never Do

- Do **not** access the database directly from `apps/web` or any client-side code.
- Do **not** bypass RLS (no `BYPASSRLS` roles outside Auth.js adapter code and maintenance scripts).
- Do **not** introduce new persistence patterns (for example, ad-hoc tables, raw SQL entrypoints) without updating the relevant spec doc.
- Do **not** add third-party UI libraries to `@repo/design-system` (keep it Tailwind + custom components).
- Do **not** run interactive commands in agents (no `vitest` watch mode; always use `--run`).

## Tech Stack & Commands

- **Backend**:
  - Node 20+
  - Hono
  - Zod → OpenAPI 3.1
  - Prisma 6 on Neon Postgres
  - Auth.js
  - Stripe
  - Plaid
  - Upstash Redis / QStash
  - Vitest
- **Frontend**:
  - Vite
  - React 19
  - React Router
  - Tailwind
  - TanStack Query
  - Plaid Link  
  - Capacitor-ready SPA architecture.
- **Tooling**:
  - pnpm workspaces
  - Turborepo
  - Biome
  - tsup
  - Husky + lint-staged
  - Playwright (E2E)
  - Changesets (planned)

**Handy commands:**

- Install deps:
    pnpm install

- Dev servers:
    pnpm dev
    pnpm dev --filter=api
    pnpm dev --filter=web

- Build:
    pnpm build
    pnpm build --filter=api

- Tests:
    pnpm test
    pnpm test:unit
    pnpm test:e2e

- Linting / types / formatting:
    pnpm lint
    pnpm typecheck
    pnpm format

- Database:
    pnpm db:migrate
    pnpm db:generate
    pnpm db:studio

- API docs + SDK:
    pnpm api:docs
    pnpm sdk:generate

## Architecture Guardrails

- Use a **layered pattern**:
  - Thin HTTP controllers → services → repositories.
- Route handlers:
  - Parse/validate requests with Zod.
  - Call services to perform business logic.
  - Translate domain errors into HTTP responses.
  - Do **not** talk to Prisma directly.
- Services:
  - Enforce business rules:
    - Uniqueness.
    - Scope validation (workspace/user).
    - Expiration windows.
  - Emit domain events (for auditing and async work).
- Repositories:
  - Stay **CRUD-only**.
  - No business rules; just persistence.
- Keep functions focused:
  - Aim for < 50 lines (ideally 20–30).
  - Prefer early returns and descriptive helpers.
- Domain errors:
  - Bubble as typed exceptions.
  - Map them to HTTP inside controllers.
- Dependency injection:
  - Pass repositories, loggers, clock utilities, etc. via constructors.
  - Keep services testable and easy to stub/memoize.
- When you must diverge from these guardrails:
  - Document the reason in code comments.
  - Link back to specs, tickets, or docs for context.

## Database Overview

For full schema details, always refer to the `database-structure-*.md` files under `docs/` (and any split section files). This section is only a high-level TL;DR.

- **Engine & ORM**
  - Neon-hosted Postgres with branching for preview environments.
  - Prisma 6 (strict), UUID v4 primary keys, `TIMESTAMPTZ` timestamps.
  - Monetary amounts are always stored as `BIGINT` cents plus a 3-letter currency code.

- **Core domain shape**
  - Identity: Auth.js adapter tables (`users`, `accounts`, `sessions`, `verification_tokens`).
  - Domain:
    - `profiles → workspaces → connections → bank_accounts → transactions → transaction_overlays`.
  - Budgets, categories, saved views, and sharing are layered on top of that core.

- **Append-only finance data**
  - Base `transactions` rows never mutate.
  - Adjustments happen via compensating entries and overlay/audit tables.
  - Any “fixes” are done via new rows, not in-place updates.

- **Multi-tenancy & RLS**
  - Everything is scoped via `profiles` and `workspaces`.
  - RLS policies depend on `current_setting('app.user_id'/'app.profile_id'/'app.workspace_id')`.
  - Workspaces borrow access to connections/accounts via explicit link/scope tables.

If you need to change the data model, propose updates in `database-structure-*.md` first, then adjust Prisma, migrations, and RLS policies to match.

## Delivery Hygiene

- Centralize docs under `docs/`:
  - `architecture/`, `guides/`, `api/`, `operations/`, `archived/`.
  - Link new material from `README.md`.
- Temporary scripts:
  - Live in `scripts/temp/` during development.
  - Either deleted or promoted into `tooling/scripts/` with docs when finished.
- Task wrap-up checklist:
  - Clean temp scripts.
  - Update docs.
  - Remove debug artifacts.
  - Verify tests.
  - Refresh:
    - `.scope/current-phase.md`
    - `.scope/project_plan.md`
- Phase completion:
  - Add `docs/phase-N-readme.md` containing:
    - Sanity checks.
    - Deliverables.
    - Metrics.
    - Lessons learned.
    - Next-step prep.
- Sanity checks:
  - Prefer executable commands (`curl`, `pnpm`) with expected outputs.
  - Cover auth, throttling, and primary flows.
  - Include failure cases (invalid tokens, over-quota, missing scopes).

## Task Tracking Cheat Sheet

- Log future items as numbered checklists using `[ ]` / `[x]` so progress stays easy to scan.
- Leave out any sensitive data or keys; use placeholders instead.
- Template:
  1. `[ ]` Task name – quick description.
- For each task, add **Sanity Checks**:
  - Quick description of how to confirm the task is truly done.
  - Prefer commands or API calls that can be re-run.

## Running tests with agents

When running tests from within an agent (or any non-interactive environment), **always run Vitest with the `--run` flag** so it doesn’t start in watch/interactive mode and hang the agent.

Use:

    npm test -- --run
    # or
    pnpm test -- --run
