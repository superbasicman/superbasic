# Database Structure — SQL Helpers, Triggers, and Workspace Allowed Accounts

This file contains the canonical SQL for:

- `workspace_allowed_accounts` table (projection of JSON scopes)
- Helper function `workspace_allows_account(...)`
- Append-only enforcement on `transactions`
- Category tree scope enforcement
- Workspace category parent scope enforcement
- Validation of `workspace_connection_links.account_scope_json`
- Validation of `transaction_overlays.splits`

These definitions back the higher-level contracts described in:

- `database-structure-constraints-indexes-and-triggers.md`
- `database-structure-rls-and-access-control.md`
- `database-structure-ledger-and-sync.md`
- `database-structure-workspaces-and-collaboration.md`

Use this file when authoring or reviewing migrations.

---

## 1. Workspace Allowed Accounts (DDL + Helper)

`workspace_allowed_accounts` is a normalized projection of `workspace_connection_links.account_scope_json`.

- **Source of truth** remains the JSON scopes on `workspace_connection_links`.
- This table is regenerated by background jobs or migrations.
- Do **not** mutate it independently.

Table DDL:

    CREATE TABLE IF NOT EXISTS workspace_allowed_accounts (
      id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
      workspace_id uuid NOT NULL REFERENCES workspaces(id),
      bank_account_id uuid NOT NULL REFERENCES bank_accounts(id),
      granted_by_profile_id uuid NOT NULL REFERENCES profiles(id),
      revoked_at timestamptz,
      created_at timestamptz NOT NULL DEFAULT now(),
      UNIQUE (workspace_id, bank_account_id) WHERE revoked_at IS NULL
    );

Convenience helper (application-level; not used directly inside RLS after predicates were inlined):

    CREATE OR REPLACE FUNCTION workspace_allows_account(workspace uuid, bank_account uuid)
    RETURNS boolean AS $$
      -- Application-level convenience helper (not used inside RLS after inlining).
      -- Never call it from policies on workspace_allowed_accounts or workspace_connection_links
      -- to avoid recursive evaluation.
      --
      -- Callers must align the workspace argument with their current auth context so
      -- EXISTS predicates stay selective.
      SELECT
        EXISTS (
          SELECT 1
          FROM workspace_allowed_accounts waa
          WHERE waa.workspace_id = workspace
            AND waa.bank_account_id = bank_account
            AND waa.revoked_at IS NULL
        )
        OR EXISTS (
          SELECT 1
          FROM workspace_connection_links wcl
          WHERE wcl.workspace_id = workspace
            AND wcl.revoked_at IS NULL
            AND (wcl.expires_at IS NULL OR wcl.expires_at > now())
            AND (
              wcl.account_scope_json IS NULL
              OR bank_account::text IN (
                   SELECT jsonb_array_elements_text(wcl.account_scope_json)
                 )
            )
        );
    $$ LANGUAGE sql STABLE;

    -- Runs as SECURITY INVOKER so the app role stays behind FORCE RLS; ensure policies above
    -- permit the necessary SELECT checks. If future use cases require bypassing RLS, flip to
    -- SECURITY DEFINER and harden search_path/role grants to prevent privilege escalation.
    --
    -- Performance note: consider pre-joining in long-running reports instead of chaining this
    -- helper inside deep RLS predicates.

---

## 2. Append-Only Enforcement for Transactions

`transactions` must be strictly append-only for `app_user`. We enforce this via triggers that reject UPDATE/DELETE.

Function:

    CREATE OR REPLACE FUNCTION prevent_transaction_mutation()
    RETURNS trigger AS $$
    BEGIN
      RAISE EXCEPTION 'transactions are append-only';
    END;
    $$ LANGUAGE plpgsql;

Triggers:

    CREATE TRIGGER transactions_no_update
      BEFORE UPDATE ON transactions
      FOR EACH ROW
      EXECUTE FUNCTION prevent_transaction_mutation();

    CREATE TRIGGER transactions_no_delete
      BEFORE DELETE ON transactions
      FOR EACH ROW
      EXECUTE FUNCTION prevent_transaction_mutation();

---

## 3. Category Tree Parent Scope Enforcement

System/profile category trees must be internally consistent:

- System categories (`profile_id IS NULL`) can only parent system nodes.
- Profile-owned categories can only parent categories for the same profile.

Function:

    CREATE OR REPLACE FUNCTION ensure_category_parent_scope()
    RETURNS trigger AS $$
    DECLARE
      parent_profile uuid;
    BEGIN
      IF NEW.parent_id IS NULL THEN
        RETURN NEW;
      END IF;

      SELECT profile_id
      INTO parent_profile
      FROM categories
      WHERE id = NEW.parent_id;

      IF (parent_profile IS DISTINCT FROM NEW.profile_id) THEN
        RAISE EXCEPTION
          'category parent must share profile scope (both NULL for system categories)';
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

Constraint trigger (deferrable to allow bulk updates):

    CREATE CONSTRAINT TRIGGER categories_parent_scope_ck
      AFTER INSERT OR UPDATE ON categories
      DEFERRABLE INITIALLY DEFERRED
      FOR EACH ROW
      EXECUTE FUNCTION ensure_category_parent_scope();

---

## 4. Workspace Category Parent Scope Enforcement

Workspace category trees must not cross workspaces:

- A workspace category’s parent must belong to the same workspace.

Function:

    CREATE OR REPLACE FUNCTION ensure_workspace_category_parent_scope()
    RETURNS trigger AS $$
    DECLARE
      parent_workspace uuid;
    BEGIN
      IF NEW.parent_id IS NULL THEN
        RETURN NEW;
      END IF;

      SELECT workspace_id
      INTO parent_workspace
      FROM workspace_categories
      WHERE id = NEW.parent_id;

      IF parent_workspace IS DISTINCT FROM NEW.workspace_id THEN
        RAISE EXCEPTION
          'workspace category parent must belong to same workspace';
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

Constraint trigger (deferrable):

    CREATE CONSTRAINT TRIGGER workspace_categories_parent_scope_ck
      AFTER INSERT OR UPDATE ON workspace_categories
      DEFERRABLE INITIALLY DEFERRED
      FOR EACH ROW
      EXECUTE FUNCTION ensure_workspace_category_parent_scope();

---

## 5. Validation of workspace_connection_links.account_scope_json

`workspace_connection_links.account_scope_json` is a JSONB array of account UUID strings used to scope connections to a subset of accounts.

Validation requirements:

- If non-NULL:
  - Must be a JSON array.
  - Each element must be a UUID string.
  - Each referenced account must:
    - Belong to the given `connection_id`.
    - Be non-deleted (`deleted_at IS NULL`).

Function:

    CREATE OR REPLACE FUNCTION validate_workspace_account_scope()
    RETURNS trigger AS $$
    DECLARE
      account_id uuid;
    BEGIN
      IF NEW.account_scope_json IS NULL THEN
        RETURN NEW;
      END IF;

      IF jsonb_typeof(NEW.account_scope_json) <> 'array' THEN
        RAISE EXCEPTION 'account_scope_json must be array of UUID strings';
      END IF;

      FOR account_id IN
        SELECT jsonb_array_elements_text(NEW.account_scope_json)::uuid
      LOOP
        IF NOT EXISTS (
          SELECT 1
          FROM bank_accounts ba
          WHERE ba.id = account_id
            AND ba.connection_id = NEW.connection_id
            AND ba.deleted_at IS NULL
        ) THEN
          RAISE EXCEPTION
            'account_scope_json contains account % that is not part of connection %',
            account_id, NEW.connection_id;
        END IF;
      END LOOP;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

Constraint trigger (deferrable):

    CREATE CONSTRAINT TRIGGER workspace_connection_links_scope_ck
      AFTER INSERT OR UPDATE ON workspace_connection_links
      DEFERRABLE INITIALLY DEFERRED
      FOR EACH ROW
      EXECUTE FUNCTION validate_workspace_account_scope();

---

## 6. Validation of transaction_overlays.splits

`transaction_overlays.splits` holds structured split metadata and must satisfy:

- If non-NULL, the value must be a JSON array.
- Each element must be a JSON object containing `amount_cents`.
- The sum of `amount_cents` across all splits must equal the base transaction’s `amount_cents`.

Function:

    CREATE OR REPLACE FUNCTION validate_transaction_overlay_splits()
    RETURNS trigger AS $$
    DECLARE
      split_record jsonb;
      total bigint := 0;
      base_amount bigint;
    BEGIN
      IF NEW.splits IS NULL OR jsonb_typeof(NEW.splits) <> 'array' THEN
        IF NEW.splits IS NOT NULL THEN
          RAISE EXCEPTION 'splits must be a JSON array';
        END IF;
        RETURN NEW;
      END IF;

      FOR split_record IN
        SELECT jsonb_array_elements(NEW.splits)
      LOOP
        IF jsonb_typeof(split_record) <> 'object'
           OR NOT split_record ? 'amount_cents' THEN
          RAISE EXCEPTION 'each split must include amount_cents';
        END IF;

        total := total + (split_record ->> 'amount_cents')::bigint;
      END LOOP;

      SELECT amount_cents
      INTO base_amount
      FROM transactions
      WHERE id = NEW.transaction_id;

      IF base_amount IS NULL THEN
        RAISE EXCEPTION 'transaction not found for overlay';
      END IF;

      IF total <> base_amount THEN
        RAISE EXCEPTION
          'split totals (%s) must equal transaction amount (%s)',
          total, base_amount;
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

Trigger:

    CREATE TRIGGER transaction_overlays_splits_validate
      BEFORE INSERT OR UPDATE ON transaction_overlays
      FOR EACH ROW
      EXECUTE FUNCTION validate_transaction_overlay_splits();

---

These helpers and triggers should be kept in lockstep with:

- The declarative constraints and indexes in `database-structure-constraints-indexes-and-triggers.md`.
- The RLS policies that rely on consistent workspace/account/category semantics.

When changing any of them, update:

1. This file (SQL reference).  
2. The corresponding narrative docs.  
3. Migration scripts and tests that depend on the behavior.
